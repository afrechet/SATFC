/*
 * SATFC Build file.
 * @author afrechet
 * @author newmanne
 * 
 * @TODO 
 *	1. Automatic git push after publish.
 *	2. Resolve native dependencies (e.g. on clasp). 
 *  3. Figure out how to work with private, password protected non-maven-central repo.
 *  4. Nicer failure on local.properties
 *
 */

// Build script dependencies.
buildscript {
	dependencies { 
		classpath 'org.ajoberstar:gradle-git:0.12.0'
	}
}

apply plugin: 'maven-publish'

// In this section you declare the dependencies for your production and test code
dependencies {
    //All the product dependencies.
    compile 'ca.ubc.cs.beta:aeatk:2.08.01-development-de3ee6617d5c'
    compile 'commons-codec:commons-codec:1.7'
    compile 'org.apache.commons:commons-lang3:3.3.1'
    compile 'org.jgrapht:jgrapht-core:0.9.0'
    compile 'au.com.bytecode:opencsv:2.4'
    compile 'com.google.guava:guava:18.0'
    compile 'org.projectlombok:lombok:1.16.10'
    
    // logging
    compile 'org.slf4j:slf4j-api:1.7.7'
    compile 'org.slf4j:slf4j-parent:1.7.5'
    compile 'ch.qos.logback:logback-access:1.0.13'
    compile 'ch.qos.logback:logback-classic:1.0.13'
    compile 'ch.qos.logback:logback-core:1.0.13'
    runtime "org.codehaus.groovy:groovy:1.8.6"
    
    // json
    compile "com.fasterxml.jackson.core:jackson-databind:$jacksonVersion"
    compile "com.fasterxml.jackson.core:jackson-core:$jacksonVersion"
    compile "com.fasterxml.jackson.core:jackson-annotations:$jacksonVersion"
    compile "com.fasterxml.jackson.datatype:jackson-datatype-guava:$jacksonVersion"
    compile "com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:$jacksonVersion"

    // csv
    compile 'org.apache.commons:commons-csv:1.3'

    compile 'com.beust:jcommander:1.35-patched'
    compile 'commons-collections:commons-collections:3.2.1'
    compile 'net.java.dev.jna:jna:4.0.0'
    compile 'com.mangosdk:spi:0.2.4'
	compile "io.dropwizard.metrics:metrics-core:$dropwizardMetricVersion"
	compile "io.dropwizard.metrics:metrics-jvm:$dropwizardMetricVersion"
    compile 'org.python:jython-standalone:2.7.0'

    // redis
    compile 'redis.clients:jedis:2.6.1'
    compile "org.springframework.data:spring-data-redis:1.5.0.RELEASE"

    // Rest template
    compile "org.springframework:spring-web:$springVersion"
    compile 'org.apache.httpcomponents:httpasyncclient:4.1'

    // CPLEX
    compile files('libs/cplex.jar')

    // Containment cache
    compile 'ca.ubc.cs.beta:ContainmentCache:0.9.4'

    compile 'com.github.mfornos:humanize-icu:1.2.2'

    // Database
    compile group: 'mysql', name: 'mysql-connector-java', version: '6.0.5'
    compile group: 'com.j256.ormlite', name: 'ormlite-core', version: '5.1'

    // Test dependencies.
    testCompile 'junit:junit:4.11'
    testCompile 'org.mockito:mockito-all:1.10.8'
}

// Creates scripts for entry points
// Subproject must apply application plugin to be able to call this method.
def createScript(project, mainClass, name, jvmArgs) {
    project.tasks.create(name: name, type: CreateStartScripts) {
        outputDir = new File(project.buildDir, 'scripts')
        mainClassName = mainClass
        applicationName = name
        classpath = project.tasks[JavaPlugin.JAR_TASK_NAME].outputs.files + project.configurations.runtime
        applicationDefaultJvmArgs = jvmArgs
    }
    project.tasks[name].dependsOn(project.jar)
    project.applicationDistribution.with {
        into("bin") {
            from(project.tasks[name])
            fileMode = 0755
        }
    }

    // This is a dumb hack to get rid of the backslash that inevitably appears before the dollar sign...
    project.tasks[name].doLast {
        def f = new File(project.buildDir, "scripts/${name}")
        def replace = f.text.replace("-Djava.library.path=\\", "-Djava.library.path=")
        f.setText(replace)
    }
}

//Project properties.
applicationName = 'SATFC'
jar.baseName = applicationName
version = "$SATFCVersion-"+getGitName()
mainClassName = 'ca.ubc.cs.beta.stationpacking.execution.SATFCFacadeExecutor'
applicationDefaultJvmArgs = ['-Djava.library.path=${CPLEX_DIR}', '-Xmx8g']

startScripts{
    doLast{
        def f = new File(getOutputDir(), applicationName)
        def replace = f.text.replace("-Djava.library.path=\\", "-Djava.library.path=")
        f.setText(replace)
    }
}

//Publishing to EARG maven repo.
public String getEARGMavenRepo()
{
	Properties properties = new Properties()
	def propertyFilename = 'local.properties'
	def propertyFile = project.rootProject.file(propertyFilename)
	if(!propertyFile.exists()) {
		println 'Necessary file '+propertyFilename+' was not present, creating an empty version of it!'
		propertyFile.createNewFile()
	}
	properties.load(propertyFile.newDataInputStream())
	def eargMavenRepo = properties.getProperty('earg.mavenrepo.dir')
	return eargMavenRepo
}

publishing {

	repositories {
	    //Local EARG maven repo.   
	    maven {
	    	url getEARGMavenRepo()+'/snapshots/'
	    }
	}
	
	publications {
	
		maven(MavenPublication) {
			groupId 'ca.ubc.cs.beta'
			artifactId applicationName
			version version
			
			from components.java
			
			artifact sourcesJar {
				classifier "sources"
			}
			artifact distZip {
				classifier "dist"
			}
		}
	
	}
}

def generatedResources = "$buildDir/generated-resources/main"

sourceSets {
    main {
        //let's register an output folder on the main SourceSet:
        output.dir(generatedResources, builtBy: 'generateMyResources')
        //it is now a part of the 'main' classpath and will be a part of the jar
    }
}

//a task that generates the resources:
task generateMyResources {
    doLast {
        def generatedFolder = new File(generatedResources)
        if (!generatedFolder.exists()) {
            generatedFolder.mkdirs()
        }
        def generated = new File(generatedResources, "version.properties")
        generated.text = "version=$version" + System.lineSeparator() + getGitInfo()
    }
}

run {
    if (project.hasProperty('args') ) {
        args project.args.split('\\s+')
    }
}
